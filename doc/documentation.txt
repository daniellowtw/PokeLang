- PokeLang
An esoteric programming language where programs are represented as a Pokemon
battle.

- General Overview
PokeLang consists of a series turns in a Pokemon battle.
Moves correspond to an operation or object.
The moves are then transcribed into a stack-oriented language called PokeStack.
The PokeStack program is then run using a PokeStack interpreter.

- Structure
The battle starts with yourself and the enemy trainer sending out a Pokemon.
Each Pokemon have unlimited number of moves, and each trainer can use any number of Pokemon.
The battle is a series of turns. Either Pokemon can go first, but switching Pokemon takes priority over making a move.

- PokeStack
PokeStack is a stack-oriented language using postfix operators.
The two key language constructs of PokeStack are objects and operators.
The program is represented as a list of objects and operators.
This is known as the Instruction List.
This program is interpreted by traversing this list.
Upon encountering an object, the object will be pushed on the stack.
Upon encountering an operator, the arguments it takes will be popped from the stack. 
The operator will perform its actions using the arguments and modify the stack. 
An operator can only take arguments from the top of the stack.

- Notation
( ) represents the stack.
 a  represents any object.
#a  represents a number.
[]a represents an array.
{}a represents a block.
(a b) represents a and b on the stack, with b being on top.
( a )[1 : b, 2: c] represents a on the stack, with 1:b and 2:c in the dictionary.

( a b ) + ( a+b )
( a b ) represents the stack before the next instruction.
+ represents the instruction.
( a+b ) represents the stack after the instruction is performed.

- Numbers
Numbers are objects. 
Numbers are represented by integers.

() #a ( #a )

- Operations

- Arithmetic

The <+> operator

( a b ) + ( a+b )

If an operation has the wrong number of arguments (e.g. too few objects on the
stack) or the type of the arguments is wrong (e.g. Block vs Number), an error
will be thrown.

- Arrays
Arrays are objects. 
An array is an indexed collection of objects. 
Arrays are not dynamically sized. 
Arrays can be nested, as they are objects themselves.

The <[> object marks the start of an array on the stack.

() [ ( [ )

The <]> operator initialises the array. 
The top object on the stack is then pushed into the tail of the array, repeating
until the <[> object is reached.
If the <[> object is not reached before the bottom of the stack, an error is
thrown. 

( [ a b c d e ) ] ( [a,b,c,d,e] ) 

Notice that <[> is an object, existing on the stack while <]> is an operator.

- Blocks
Blocks are objects.
A block is a structure used to store objects and operations. 
Blocks can be nested as they are objects.
Blocks are created at compile time.

<{> represents the start of the block.
<}> represents the end of the block.

Note that <{> and <}> are not operators or objects. 
The entire block is treated as a single object.

() {}a ( {}a )

The <exec> operator takes a block and after the current node of the Instruction
List, inserts the instructions of the block in order. 
If the argument of <exec> is not a block, an error is thrown.

( 1 { 1 + } ) exec ( 2 )

Breaking the above down into steps:

( 1 { 1 + } ) exec ( 1 ) 

The next instruction is then 1 followed by +

( 1 ) 1 ( 1 1 )

( 1 1 ) + ( 2 )

- Dictionary
Objects can be stored in a global dictionary. 
The dictionary stores key-value pairs. 
A key can be any number, and the value any object.

The <store> takes a key and a object and puts it into the dictionary. 
If there already exists an entry for the key, it will be overwritten.

( #a b ) store ()[#a: b]

The <load> operator takes a key and pushes the value from the dictionary on the stack. 
If there does not exist a key-value pair, an error will be thrown.

( #a )[#a: b] load ( b )[#a: b]

Using a combination of <load>, <store> and <exec>, subroutines can be defined.

4 { dup * } store 5 4 load exec 4 load exec 

The { dup * } results in a squaring the top object of the stack.

Performing { dup * } twice on 5 results in 625.

This is represented in PokeLang by:

  // Turn 1
  > Go! PIKACHU!
  > Foe SABRINA sends out BUTTERFREE!
  > PIKACHU! That's enough! Come back!
  > Go! CHARMANDER! 
  > Foe BUTTERFREE uses TACKLE!               // 4

  // Turn 2
  > CHARMANDER uses SCRATCH!                  // {
  > Foe BUTTERFREE uses GUST!                 // DUP
  
  // Turn 3
  > Foe SABRINA calls back BUTTERFREE!
  > Foe SABRINA sends out ALAKAZAM! 
  > CHARMANDER uses FLAMETHROWER!             // *
  
  // Turn 4
  > CHARMANDER uses SLASH!                    // }
  > Foe ALAKAZAM uses CONFUSION!              // STORE
  
  // Turn 5
  > CHARMANDER! That's enough! Come back!
  > Go! CHARIZARD! 
  > Foe SABRINA calls back ALAKAZAM!
  > Foe SABRINA sends out BUTTERFREE! 

  // Turn 6
  > CHARMANDER! That's enough! Come back!
  > Go! CHARMELEON!
  > Foe BUTTERFREE uses TACKLE!               // 5
  
  // Turn 7
  > CHARMELEON! That's enough! Come back!
  > Go! CHARMANDDER! 
  > Foe BUTTERFREE uses TACKLE!               // 4

  // Turn 8
  > CHARMANDER! That's enough! Come back!
  > Go! PIKACHU! 
  > Foe BUTTERFREE uses PSYBEAM!              // LOAD
  
  // Turn 9
  > Foe SABRINA calls back BUTTERFREE!
  > Foe SABRINA sends out ALAKAZAM! 
  > PIKACHU uses THUNDER SHOCK!               // EXEC

  // Turn 10
  > PIKACHU! That's enough! Come back!
  > Go! CHARMELEON! 
  > Foe SABRINA calls back ALAKAZAM!
  > Foe SABRINA sends out BUTTERFREE! 

  // Turn 11
  > CHARMELEON! That's enough! Come back!
  > Go! CHARMANDDER! 
  > Foe BUTTERFREE uses TACKLE!               // 4
 
  // Turn 12
  > CHARMANDER! That's enough! Come back!
  > Go! PIKACHU! 
  > Foe BUTTERFREE uses PSYBEAM!              // LOAD

  // Turn 13
  > PIKACHU uses THUNDERSHOCK!                // EXEC



